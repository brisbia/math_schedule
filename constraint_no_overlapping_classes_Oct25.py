#!/usr/bin/env python
# coding: utf-8


# In[ ]:

from docplex.mp.priority import Priority


def constraint_no_overlapping_classes(df_time_assigned, all_profs, mdl):
    ''' 
    Inputs:
    - df_time_assigned - a dataframe containing columns all_times (containing integers corresponding to time values), and assigned (containing binary assignment variables generated by the cplex model)
    - all_profs - an object containing the name of all professors teaching classes
    - mdl - a cplex model that will have constraints added to it by this function
    
    returns mdl, the same cplex model as before with constraints added it it. This function should work in-place.
    This function adds constraints such that, if a professor is teaching a class that starts at time X, that professor cannot teach any other class that begins at a time Y such that Y overlaps X.
    
    Created by Theodore 2025-10-1
    ''' 
    for times in df_time_assigned['all_times'].unique():
        df_time_separate = df_time_assigned.loc[df_time_assigned['all_times']==times].copy().reset_index() # fixed the "value being set on a copy" warning
        df_time_separate = df_time_separate.dropna()
        #print(df_time_separate)
        #### adding for asych, sinch was trying to do below actions on empty dataframe as nans were dropped
        if not df_time_separate.empty:
            df_time_overlap_options = df_time_assigned.loc[df_time_assigned['all_times'].isin(df_time_separate['overlap_times'][0])]
            for prof in all_profs:
                #print(f'{prof}, time {times}')
                df_overlap_prof = df_time_overlap_options.loc[df_time_overlap_options['all_profs']==prof]
                # Drop duplicate course-time pairs (avoid problems with Math 347)
                df_overlap_prof = df_overlap_prof.drop_duplicates(["all_courses_and_times"]) # Added by Dr. Abra on 8/1/2024

                # The number of classes `prof` can teach in timeslot `times` is <= 1.
                mdl.add_constraint(mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned'])<=1).priority = Priority.VERY_HIGH
                if len(df_overlap_prof['all_times'].unique()) >1:
                    #print(len(df_overlap_prof['all_times'].unique()))
                    # If there are other timeslots that overlap with this one, and `prof` teaches at timeslot `times`,
                    # then they cannot teach during any of the *other* overlapping timeslots
                    #if times == 55:
                        #print(sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned']))
                    mdl.add_if_then(mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned'])==1, mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']!=times]['assigned'])==0).priority = Priority.VERY_HIGH
    return mdl


# In[ ]:


# for times in df_time_assigned['all_times'].unique():
#     df_time_separate = df_time_assigned.loc[df_time_assigned['all_times']==times].copy().reset_index() # fixed the "value being set on a copy" warning
#     df_time_separate = df_time_separate.dropna()
#     #print(df_time_separate)
#     #### adding for asych, sinch was trying to do below actions on empty dataframe as nans were dropped
#     if not df_time_separate.empty:
#         df_time_overlap_options = df_time_assigned.loc[df_time_assigned['all_times'].isin(df_time_separate['overlap_times'][0])]
#         for prof in all_profs:
#             #print(f'{prof}, time {times}')
#             df_overlap_prof = df_time_overlap_options.loc[df_time_overlap_options['all_profs']==prof]
#             # Drop duplicate course-time pairs (avoid problems with Math 347)
#             df_overlap_prof = df_overlap_prof.drop_duplicates(["all_courses_and_times"]) # Added by Dr. Abra on 8/1/2024

#             # The number of classes `prof` can teach in timeslot `times` is <= 1.
#             mdl.add_constraint(mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned'])<=1).priority = Priority.VERY_HIGH
#             if len(df_overlap_prof['all_times'].unique()) >1:
#                 #print(len(df_overlap_prof['all_times'].unique()))
#                 # If there are other timeslots that overlap with this one, and `prof` teaches at timeslot `times`,
#                 # then they cannot teach during any of the *other* overlapping timeslots
#                 #if times == 55:
#                     #print(sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned']))
#                 mdl.add_if_then(mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']==times]['assigned'])==1, mdl.sum(df_overlap_prof.loc[df_overlap_prof['all_times']!=times]['assigned'])==0).priority = Priority.VERY_HIGH
# #df_overlap_prof
# #adding the constraint for overlapping times, look at the list of overlapping times, find the prof and all those times say if one not the other

